<!DOCTYPE html>
<html lang="zh-CN" data-color-mode="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åšå®¢åˆ›ä½œä¸­å¿ƒ - bwliubase</title>
    
    <!-- æ ¸å¿ƒæ ·å¼ -->
    <style>
    :root {
        --primary: #0969da;
        --bg-base: #ffffff;
        --bg-secondary: #f6f8fa;
        --border: #d0d7de;
        --text: #24292f;
        --text-light: #57606a;
        --font-base: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif;
        --font-code: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
        --radius: 6px;
        --shadow: 0 1px 3px rgba(0,0,0,0.12);
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        background: var(--bg-secondary);
        font-family: var(--font-base);
        color: var(--text);
        line-height: 1.6;
        min-height: 100vh;
        padding: 1rem;
    }

    .editor-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1.5rem;
        max-width: 1600px;
        margin: 0 auto;
        height: calc(100vh - 2rem);
    }

    .editor-pane {
        background: var(--bg-base);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
    }

    .editor-toolbar {
        padding: 0.8rem;
        border-bottom: 1px solid var(--border);
        display: flex;
        gap: 0.6rem;
        flex-wrap: wrap;
        background: var(--bg-secondary);
        border-radius: var(--radius) var(--radius) 0 0;
    }

    .tool-btn {
        padding: 0.4rem 0.8rem;
        background: var(--bg-base);
        border: 1px solid var(--border);
        border-radius: calc(var(--radius) - 2px);
        cursor: pointer;
        transition: all 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
    }

    .tool-btn:hover {
        background: var(--primary);
        border-color: var(--primary);
        color: white;
    }

    #editor {
        flex: 1;
        padding: 1.2rem;
        border: 0;
        resize: none;
        font-family: var(--font-code);
        font-size: 14px;
        line-height: 1.5;
        tab-size: 4;
        background: var(--bg-base);
        color: var(--text);
    }

    .preview-pane {
        background: var(--bg-base);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 1.2rem;
        overflow-y: auto;
        box-shadow: var(--shadow);
    }

    @media (max-width: 768px) {
        .editor-container {
            grid-template-columns: 1fr;
            height: auto;
        }
        
        .editor-pane {
            height: 60vh;
        }
    }
    </style>
</head>
<body>
    <div class="editor-container">
        <!-- ç¼–è¾‘å™¨å·¦ä¾§ -->
        <div class="editor-pane">
            <div class="editor-toolbar">
                <button class="tool-btn" data-action="bold">B</button>
                <button class="tool-btn" data-action="italic">I</button>
                <button class="tool-btn" data-action="code">Code</button>
                <button class="tool-btn" data-action="image">Image</button>
                <input type="file" id="imageUpload" hidden accept="image/*">
            </div>
            <textarea id="editor" placeholder="å¼€å§‹æ’°å†™ä½ çš„åšå®¢..."></textarea>
        </div>

        <!-- é¢„è§ˆå³ä¾§ -->
        <div class="preview-pane" id="preview"></div>
    </div>

    <!-- åŸºç¡€è„šæœ¬ -->
    <script>
    // ç¼–è¾‘å™¨æ ¸å¿ƒé…ç½®
    const editor = document.getElementById('editor');
    const preview = document.getElementById('preview');
    let isDraftSaved = true;

    // åˆå§‹åŒ–ç¼–è¾‘å™¨
    function initEditor() {
        // åŠ è½½è‰ç¨¿
        const draft = localStorage.getItem('blog_draft');
        if(draft) {
            editor.value = draft;
            updatePreview();
        }

        // è¾“å…¥ç›‘å¬
        editor.addEventListener('input', () => {
            isDraftSaved = false;
            updatePreview();
            autoSaveDraft();
        });

        // å·¥å…·æ äº‹ä»¶
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', handleToolbarAction);
        });
    }

    // æ›´æ–°é¢„è§ˆ
    function updatePreview() {
        preview.innerHTML = editor.value;
    }

    // è‡ªåŠ¨ä¿å­˜è‰ç¨¿ï¼ˆèŠ‚æµï¼‰
    let saveTimer;
    function autoSaveDraft() {
        clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
            localStorage.setItem('blog_draft', editor.value);
            isDraftSaved = true;
        }, 2000);
    }

    // å·¥å…·æ æ“ä½œå¤„ç†
    function handleToolbarAction(e) {
        const action = e.target.dataset.action;
        switch(action) {
            case 'bold':
                wrapSelection('**', '**');
                break;
            case 'italic':
                wrapSelection('_', '_');
                break;
            case 'code':
                wrapSelection('```\n', '\n```');
                break;
            case 'image':
                document.getElementById('imageUpload').click();
                break;
        }
    }

    // æ–‡æœ¬é€‰æ‹©å¤„ç†
    function wrapSelection(prefix, suffix) {
        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        const selected = editor.value.substring(start, end);
        
        editor.setRangeText(prefix + selected + suffix);
        editor.focus();
        editor.selectionStart = start + prefix.length;
        editor.selectionEnd = end + prefix.length;
    }

    // åˆå§‹åŒ–
    window.onload = initEditor;
    </script>
    <!-- æ¥ä¸Šæ–‡ -->
    <script>
    // åˆå§‹åŒ–Markdownè§£æå™¨
    const markedConfig = {
        breaks: true,
        gfm: true,
        headerIds: false,
        highlight: (code, lang) => {
            const validLang = hljs.getLanguage(lang) ? lang : 'plaintext';
            return hljs.highlight(code, { language: validLang }).value;
        }
    };
    
    // å¢å¼ºé¢„è§ˆåŠŸèƒ½
    function updatePreview() {
        marked.parse(editor.value, markedConfig, (err, html) => {
            if (!err) {
                preview.innerHTML = html;
                addCodeCopyButtons();
                renderMathExpressions();
                applyImageZoom();
            }
        });
    }
    
    // ä»£ç å—å¤åˆ¶åŠŸèƒ½
    function addCodeCopyButtons() {
        document.querySelectorAll('pre code').forEach(block => {
            if (block.previousElementSibling?.classList.contains('copy-btn')) return;
            
            const btn = document.createElement('button');
            btn.className = 'copy-btn';
            btn.innerHTML = 'ğŸ“‹';
            btn.title = 'å¤åˆ¶ä»£ç ';
            btn.addEventListener('click', () => {
                navigator.clipboard.writeText(block.textContent);
                btn.innerHTML = 'âœ…';
                setTimeout(() => btn.innerHTML = 'ğŸ“‹', 2000);
            });
            block.parentNode.insertBefore(btn, block);
        });
    }
    
    // å›¾ç‰‡å¤„ç†ç³»ç»Ÿ
    document.getElementById('imageUpload').addEventListener('change', async function(e) {
        const files = Array.from(e.target.files);
        for (const file of files) {
            try {
                const reader = new FileReader();
                reader.onload = () => {
                    insertImageMarkdown(file.name, reader.result);
                };
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('å›¾ç‰‡ä¸Šä¼ å¤±è´¥:', error);
            }
        }
    });
    
    function insertImageMarkdown(alt, src) {
        const markdown = `![${alt}](${src})`;
        const start = editor.selectionStart;
        editor.value = editor.value.slice(0, start) + markdown + editor.value.slice(start);
        editor.focus();
        editor.selectionStart = editor.selectionEnd = start + markdown.length;
        updatePreview();
    }
    
    // è¡¨æ ¼ç”Ÿæˆå™¨
    let tableDialog = null;
    function initTableGenerator() {
        tableDialog = document.createElement('div');
        tableDialog.className = 'table-dialog';
        tableDialog.innerHTML = `
            <div class="dialog-content">
                <h3>åˆ›å»ºè¡¨æ ¼</h3>
                <div class="table-config">
                    <label>è¡Œæ•°: <input type="number" id="rows" min="1" value="3"></label>
                    <label>åˆ—æ•°: <input type="number" id="cols" min="1" value="3"></label>
                    <button onclick="generateTable()">ç”Ÿæˆ</button>
                    <button onclick="closeTableDialog()">å–æ¶ˆ</button>
                </div>
            </div>
        `;
        document.body.appendChild(tableDialog);
    }
    
    function generateTable() {
        const rows = parseInt(document.getElementById('rows').value) || 3;
        const cols = parseInt(document.getElementById('cols').value) || 3;
        
        let tableMd = '';
        // ç”Ÿæˆè¡¨å¤´
        tableMd += '| ' + ' Header |'.repeat(cols) + '\n';
        tableMd += '|' + ' --- |'.repeat(cols) + '\n';
        
        // ç”Ÿæˆè¡¨æ ¼å†…å®¹
        for (let i = 0; i < rows; i++) {
            tableMd += '| ' + ' Content |'.repeat(cols) + '\n';
        }
        
        insertTextAtCursor(tableMd);
        closeTableDialog();
    }
    
    // é€šç”¨å·¥å…·å‡½æ•°
    function insertTextAtCursor(text) {
        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        editor.value = editor.value.slice(0, start) + text + editor.value.slice(end);
        editor.focus();
        editor.selectionStart = editor.selectionEnd = start + text.length;
        updatePreview();
    }
    
    // æ•°å­¦å…¬å¼æ”¯æŒ
    function renderMathExpressions() {
        const inlineMath = /\\\((.*?)\\\)/g;
        const blockMath = /\\\[(.*?)\\\]/g;
        
        preview.innerHTML = preview.innerHTML
            .replace(inlineMath, (_, expr) => katex.renderToString(expr))
            .replace(blockMath, (_, expr) => katex.renderToString(expr, { displayMode: true }));
    }
    
    // å›¾ç‰‡ç¼©æ”¾äº¤äº’
    function applyImageZoom() {
        preview.querySelectorAll('img').forEach(img => {
            img.style.cursor = 'zoom-in';
            img.onclick = () => {
                if (img.style.transform === 'scale(2)') {
                    img.style.transform = 'scale(1)';
                } else {
                    img.style.transform = 'scale(2)';
                    img.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            };
        });
    }
    
    // åˆå§‹åŒ–æ‰©å±•åŠŸèƒ½
    function initExtensions() {
        hljs.configure({
            languages: ['javascript', 'python', 'java', 'cpp', 'bash', 'json', 'html', 'css'],
            ignoreUnescapedHTML: true
        });
        
        initTableGenerator();
        
        // æ•°å­¦å…¬å¼é…ç½®
        window.katex = {
            macros: { "\\RR": "\\mathbb{R}" }
        };
    }
    
    // å¢å¼ºåˆå§‹åŒ–æµç¨‹
    function initEditor() {
        // åŸæœ‰åˆå§‹åŒ–ä»£ç ...
        initExtensions(); // æ–°å¢æ‰©å±•åˆå§‹åŒ–
    }
    
    // æ ·å¼å¢å¼º
    const additionalStyles = `
    /* ä»£ç å—æ ·å¼ */
    .hljs {
        padding: 1.2em;
        border-radius: 6px;
        font-size: 14px;
        line-height: 1.5;
        margin: 1em 0;
        position: relative;
    }
    
    .copy-btn {
        position: absolute;
        right: 8px;
        top: 8px;
        background: rgba(255,255,255,0.9);
        border: 1px solid var(--border);
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: opacity 0.2s;
    }
    
    .table-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--bg-base);
        padding: 1.5rem;
        border-radius: var(--radius);
        box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        z-index: 1000;
    }
    
    .table-dialog input {
        padding: 0.4rem;
        border: 1px solid var(--border);
        border-radius: 4px;
        margin: 0.5rem;
    }
    
    @media (max-width: 768px) {
        .table-dialog {
            width: 90%;
            padding: 1rem;
        }
    }
    `;
    
    const styleSheet = document.createElement('style');
    styleSheet.innerHTML = additionalStyles;
    document.head.appendChild(styleSheet);
    </script>
    <!-- æ¥ä¸Šæ–‡ -->
    <script>
    // è¡¨æƒ…ç¬¦å·ç³»ç»Ÿ
    const EMOJI_CATEGORIES = {
        'people': ['ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ˜‚', 'ğŸ¤£', 'ğŸ˜Š', 'ğŸ˜‡'],
        'nature': ['ğŸ¶', 'ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯'],
        'symbols': ['â¤ï¸', 'âœ¨', 'â­', 'ğŸ”¥', 'ğŸ’¡', 'ğŸ‰', 'âœ…', 'âŒ', 'âš ï¸', 'âš¡']
    };
    
    let emojiPicker = null;
    function initEmojiPicker() {
        emojiPicker = document.createElement('div');
        emojiPicker.className = 'emoji-picker';
        emojiPicker.innerHTML = `
            <div class="emoji-tabs">
                ${Object.keys(EMOJI_CATEGORIES).map(cat => `
                    <button class="emoji-tab" data-cat="${cat}">${cat}</button>
                `).join('')}
            </div>
            <div class="emoji-container"></div>
        `;
        document.body.appendChild(emojiPicker);
        
        // äº‹ä»¶ç»‘å®š
        emojiPicker.querySelectorAll('.emoji-tab').forEach(tab => {
            tab.addEventListener('click', () => showEmojiCategory(tab.dataset.cat));
        });
    }
    
    function showEmojiPicker(event) {
        emojiPicker.style.display = 'block';
        emojiPicker.style.left = `${event.clientX - 200}px`;
        emojiPicker.style.top = `${event.clientY + 10}px`;
        showEmojiCategory('people');
    }
    
    function showEmojiCategory(category) {
        const container = emojiPicker.querySelector('.emoji-container');
        container.innerHTML = EMOJI_CATEGORIES[category].map(emoji => `
            <span class="emoji-item" data-emoji="${emoji}">${emoji}</span>
        `).join('');
        
        // ç»‘å®šç‚¹å‡»äº‹ä»¶
        container.querySelectorAll('.emoji-item').forEach(item => {
            item.addEventListener('click', () => insertEmoji(item.dataset.emoji));
        });
    }
    
    function insertEmoji(emoji) {
        insertTextAtCursor(emoji);
        emojiPicker.style.display = 'none';
    }
    
    // ç‰ˆæœ¬å†å²ç®¡ç†ç³»ç»Ÿ
    const HISTORY_MAX = 5;
    let editHistory = JSON.parse(localStorage.getItem('editHistory') || [];
    
    function saveHistory() {
        const content = editor.value;
        if (content === editHistory[editHistory.length - 1]?.content) return;
        
        editHistory.push({
            content,
            timestamp: new Date().toISOString(),
            wordCount: content.length
        });
        
        if (editHistory.length > HISTORY_MAX) {
            editHistory = editHistory.slice(-HISTORY_MAX);
        }
        
        localStorage.setItem('editHistory', JSON.stringify(editHistory));
        renderHistoryList();
    }
    
    function renderHistoryList() {
        const list = document.getElementById('historyList');
        list.innerHTML = editHistory.map((entry, index) => `
            <li class="history-item">
                <div class="history-meta">
                    <span>ç‰ˆæœ¬ ${index + 1}</span>
                    <small>${new Date(entry.timestamp).toLocaleString()}</small>
                </div>
                <button class="restore-btn" data-index="${index}">æ¢å¤</button>
            </li>
        `).join('');
        
        // ç»‘å®šæ¢å¤äº‹ä»¶
        list.querySelectorAll('.restore-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const content = editHistory[btn.dataset.index].content;
                editor.value = content;
                updatePreview();
            });
        });
    }
    
    // æ–‡ç« å‘å¸ƒç³»ç»Ÿ
    const PUBLISH_API = 'https://api.example.com/publish'; // æ›¿æ¢ä¸ºå®é™…API
    
    async function publishArticle() {
        const article = {
            title: document.getElementById('articleTitle').value,
            content: editor.value,
            tags: Array.from(document.querySelectorAll('.tag-item')).map(tag => tag.textContent),
            meta: {
                wordCount: editor.value.length,
                created: new Date().toISOString()
            }
        };
    
        try {
            const response = await fetch(PUBLISH_API, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(article)
            });
            
            if (response.ok) {
                clearDraft();
                showToast('æ–‡ç« å‘å¸ƒæˆåŠŸ!');
            } else {
                throw new Error('å‘å¸ƒå¤±è´¥');
            }
        } catch (error) {
            showToast('å‘å¸ƒå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');
        }
    }
    
    function clearDraft() {
        editor.value = '';
        localStorage.removeItem('blog_draft');
        editHistory = [];
        updatePreview();
    }
    
    // è‡ªåŠ¨ä¿å­˜ä¼˜åŒ–
    let autoSaveTimer;
    function setupAutoSave() {
        const THROTTLE_TIME = 15000; // 15ç§’
        
        editor.addEventListener('input', () => {
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(() => {
                saveHistory();
                localStorage.setItem('blog_draft', editor.value);
            }, THROTTLE_TIME);
        });
        
        window.addEventListener('beforeunload', (e) => {
            if (!isDraftSaved) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    }
    
    // å¿«æ·é”®ç³»ç»Ÿ
    function initShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + S
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveHistory();
                showToast('è‰ç¨¿å·²ä¿å­˜');
            }
            
            // Ctrl/Cmd + B
            if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
                e.preventDefault();
                wrapSelection('**', '**');
            }
            
            // Ctrl/Cmd + I
            if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
                e.preventDefault();
                wrapSelection('_', '_');
            }
        });
    }
    
    // è¾…åŠ©UIç»„ä»¶
    function showToast(message, type = 'success') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        document.body.appendChild(toast);
        
        setTimeout(() => toast.remove(), 3000);
    }
    
    // åˆå§‹åŒ–æ‰©å±•åŠŸèƒ½
    function initEditor() {
        // åŸæœ‰åˆå§‹åŒ–...
        initEmojiPicker();
        setupAutoSave();
        initShortcuts();
        renderHistoryList();
        
        // å‘å¸ƒæŒ‰é’®äº‹ä»¶
        document.getElementById('publishBtn').addEventListener('click', publishArticle);
    }
    
    // æ–°å¢æ ·å¼
    const advancedStyles = `
    /* è¡¨æƒ…é¢æ¿ */
    .emoji-picker {
        position: fixed;
        background: var(--bg-base);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        width: 320px;
        max-height: 400px;
        z-index: 1000;
        display: none;
    }
    
    .emoji-tabs {
        display: flex;
        border-bottom: 1px solid var(--border);
        padding: 8px;
    }
    
    .emoji-tab {
        padding: 6px 12px;
        border: none;
        background: none;
        cursor: pointer;
    }
    
    .emoji-tab:hover {
        background: var(--bg-secondary);
    }
    
    .emoji-container {
        padding: 12px;
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        gap: 8px;
        max-height: 340px;
        overflow-y: auto;
    }
    
    .emoji-item {
        font-size: 24px;
        cursor: pointer;
        text-align: center;
        transition: transform 0.2s;
    }
    
    .emoji-item:hover {
        transform: scale(1.2);
    }
    
    /* å†å²ç‰ˆæœ¬ */
    .history-panel {
        background: var(--bg-base);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 16px;
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 280px;
        max-height: 400px;
        overflow-y: auto;
        box-shadow: var(--shadow);
    }
    
    .history-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid var(--border);
    }
    
    .restore-btn {
        padding: 4px 8px;
        background: var(--primary);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    
    /* å“åº”å¼ä¼˜åŒ– */
    @media (max-width: 768px) {
        .history-panel {
            position: static;
            width: 100%;
            margin-top: 1rem;
        }
        
        .emoji-picker {
            width: 280px;
            left: 50% !important;
            transform: translateX(-50%);
        }
    }
    `;
    
    const styleEl = document.createElement('style');
    styleEl.textContent = advancedStyles;
    document.head.appendChild(styleEl);
    </script>
    <!-- æ¥ä¸Šæ–‡ -->
    <script>
    // ç”¨æˆ·è®¤è¯ç³»ç»Ÿ
    let currentUser = null;
    
    function initAuth() {
        const authToken = localStorage.getItem('authToken');
        if (authToken) {
            fetchUserProfile(authToken);
        }
        
        // åˆå§‹åŒ–ç™»å½•æŒ‰é’®
        const authBtn = document.createElement('div');
        authBtn.id = 'authWidget';
        authBtn.innerHTML = `
            ${currentUser ? `
                <div class="user-panel">
                    <img src="${currentUser.avatar}" class="user-avatar">
                    <span>${currentUser.name}</span>
                    <button onclick="logout()">ç™»å‡º</button>
                </div>
            ` : '<button onclick="showLogin()">ç™»å½•</button>'}
        `;
        document.body.prepend(authBtn);
    }
    
    async function fetchUserProfile(token) {
        try {
            const res = await fetch('/api/user', {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            currentUser = await res.json();
            updateAuthUI();
        } catch (error) {
            console.error('ç”¨æˆ·ä¿¡æ¯è·å–å¤±è´¥:', error);
        }
    }
    
    function showLogin() {
        const dialog = document.createElement('div');
        dialog.className = 'auth-dialog';
        dialog.innerHTML = `
            <h3>ç™»å½• bwliubase</h3>
            <input type="text" id="username" placeholder="ç”¨æˆ·å/é‚®ç®±">
            <input type="password" id="password" placeholder="å¯†ç ">
            <button onclick="handleLogin()">ç™»å½•</button>
            <button onclick="dialog.remove()">å–æ¶ˆ</button>
        `;
        document.body.appendChild(dialog);
    }
    
    async function handleLogin() {
        const credentials = {
            id: document.getElementById('username').value,
            password: document.getElementById('password').value
        };
    
        try {
            const res = await fetch('/api/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(credentials)
            });
            
            const { token } = await res.json();
            localStorage.setItem('authToken', token);
            fetchUserProfile(token);
        } catch (error) {
            showToast('ç™»å½•å¤±è´¥', 'error');
        }
    }
    
    function logout() {
        localStorage.removeItem('authToken');
        currentUser = null;
        updateAuthUI();
    }
    
    // å¤šå›¾æ‰¹é‡ä¸Šä¼ 
    async function handleBatchUpload(files) {
        const uploads = Array.from(files).map(file => {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = () => {
                    resolve({ name: file.name, data: reader.result });
                };
                reader.readAsDataURL(file);
            });
        });
    
        const results = await Promise.all(uploads);
        const markdown = results.map(f => `![${f.name}](${f.data})`).join('\n\n');
        insertTextAtCursor(markdown);
    }
    
    // æ–‡ç« æ¨¡æ¿ç³»ç»Ÿ
    const TEMPLATES = {
        default: `# æ ‡é¢˜\n\nå¼€å§‹åˆ›ä½œ...`,
        tech: `## èƒŒæ™¯\n\n## å®ç°æ–¹æ¡ˆ\n\n### æ ¸å¿ƒæŠ€æœ¯\n\n## æ•ˆæœå±•ç¤º\n\n## æ€»ç»“`,
        tutorial: `## å‰ç½®çŸ¥è¯†\n\n## æ­¥éª¤è¯´æ˜\n\n### ç¬¬ä¸€æ­¥\n\n## å¸¸è§é—®é¢˜\n\n## å‚è€ƒèµ„æ–™`
    };
    
    function applyTemplate(templateKey) {
        if (editor.value && !confirm('å½“å‰å†…å®¹å°†è¢«æ›¿æ¢ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ')) return;
        editor.value = TEMPLATES[templateKey] || TEMPLATES.default;
        updatePreview();
    }
    
    // ç›®å½•ç”Ÿæˆå™¨
    function generateTOC() {
        const headings = Array.from(preview.querySelectorAll('h1, h2, h3'));
        if (headings.length === 0) {
            return showToast('æœªæ£€æµ‹åˆ°æ ‡é¢˜', 'warning');
        }
    
        const toc = headings.map(h => {
            const level = parseInt(h.tagName[1]);
            return `${'  '.repeat(level - 1)}- [${h.textContent}](#${h.id})`;
        }).join('\n');
    
        insertTextAtCursor(`## ç›®å½•\n${toc}\n\n`);
    }
    
    // é«˜çº§ä»£ç å—è®¾ç½®
    function initCodeSettings() {
        document.querySelectorAll('pre code').forEach(block => {
            const lang = block.className.replace('language-', '');
            const btn = document.createElement('button');
            btn.className = 'code-settings-btn';
            btn.innerHTML = 'âš™ï¸';
            
            btn.addEventListener('click', () => {
                showCodeSettings(block, lang);
            });
            
            block.parentNode.insertBefore(btn, block.nextSibling);
        });
    }
    
    function showCodeSettings(codeBlock, lang) {
        const dialog = document.createElement('div');
        dialog.className = 'code-dialog';
        dialog.innerHTML = `
            <h4>ä»£ç è®¾ç½® (${lang})</h4>
            <label>è¡Œå·æ˜¾ç¤º <input type="checkbox" ${codeBlock.classList.contains('line-numbers') ? 'checked' : ''}></label>
            <button onclick="toggleLineNumbers(this)">åº”ç”¨</button>
        `;
        codeBlock.parentNode.appendChild(dialog);
    }
    
    function toggleLineNumbers(btn) {
        const checkbox = btn.previousElementSibling;
        const codeBlock = btn.closest('pre').querySelector('code');
        codeBlock.classList.toggle('line-numbers', checkbox.checked);
        btn.parentNode.remove();
    }
    
    // æ–‡ç« ç»Ÿè®¡é¢æ¿
    function initStatsPanel() {
        const stats = document.createElement('div');
        stats.id = 'statsPanel';
        stats.innerHTML = `
            <h4>æ–‡ç« ç»Ÿè®¡</h4>
            <div class="stats-item">
                <span>å­—æ•°</span>
                <span id="wordCount">0</span>
            </div>
            <div class="stats-item">
                <span>æ®µè½</span>
                <span id="paraCount">0</span>
            </div>
            <div class="stats-item">
                <span>ä»£ç å—</span>
                <span id="codeCount">0</span>
            </div>
        `;
        document.body.appendChild(stats);
        updateStats();
    }
    
    function updateStats() {
        const content = editor.value;
        document.getElementById('wordCount').textContent = content.length;
        document.getElementById('paraCount').textContent = (content.match(/\n{2,}/g) || []).length + 1;
        document.getElementById('codeCount').textContent = (content.match(/```/g) || []).length / 2;
    }
    
    // æœ€ç»ˆåˆå§‹åŒ–
    function initEditor() {
        // å…ˆå‰åˆå§‹åŒ–ä»£ç ...
        initAuth();
        initStatsPanel();
        setInterval(updateStats, 5000);
        
        // æ‰©å±•ç¼–è¾‘å™¨äº‹ä»¶
        editor.addEventListener('dragover', handleDragOver);
        editor.addEventListener('drop', handleFileDrop);
    }
    
    // æ‹–æ”¾æ–‡ä»¶å¤„ç†
    function handleDragOver(e) {
        e.preventDefault();
        editor.classList.add('dragover');
    }
    
    function handleFileDrop(e) {
        e.preventDefault();
        editor.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleBatchUpload(files);
        }
    }
    
    // æœ€ç»ˆæ ·å¼è¡¥å……
    const finalStyles = `
    /* ç”¨æˆ·è®¤è¯ */
    #authWidget {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 2000;
        background: var(--bg-base);
        padding: 8px 16px;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
    }
    
    .user-panel {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .user-avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
    }
    
    .auth-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--bg-base);
        padding: 24px;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        z-index: 3000;
        display: grid;
        gap: 12px;
        min-width: 300px;
    }
    
    /* ç»Ÿè®¡é¢æ¿ */
    #statsPanel {
        position: fixed;
        left: 20px;
        bottom: 20px;
        background: var(--bg-base);
        padding: 16px;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        min-width: 180px;
    }
    
    .stats-item {
        display: flex;
        justify-content: space-between;
        margin: 8px 0;
    }
    
    /* ä»£ç è®¾ç½® */
    .code-dialog {
        position: absolute;
        right: 0;
        top: 0;
        background: var(--bg-base);
        border: 1px solid var(--border);
        padding: 8px;
        border-radius: var(--radius);
        z-index: 100;
    }
    
    .code-settings-btn {
        position: absolute;
        right: 35px;
        top: 8px;
        background: none;
        border: none;
        cursor: pointer;
        opacity: 0.6;
    }
    
    .code-settings-btn:hover {
        opacity: 1;
    }
    
    /* æ‹–æ”¾æ•ˆæœ */
    .dragover {
        outline: 2px dashed var(--primary);
        background: rgba(9, 105, 218, 0.1) !important;
    }
    `;
    
    document.head.insertAdjacentHTML('beforeend', `<style>${finalStyles}</style>`);
    </script>
    <!-- æ¥ä¸Šæ–‡ -->
    <script>
    // æ–‡ç« å…ƒæ•°æ®ç®¡ç†
    const metaForm = document.createElement('form');
    metaForm.id = 'metaForm';
    metaForm.innerHTML = `
        <div class="meta-section">
            <h3>æ–‡ç« è®¾ç½®</h3>
            <div class="form-group">
                <label>æ ‡é¢˜ï¼š</label>
                <input type="text" id="postTitle" required>
            </div>
            <div class="form-group">
                <label>åˆ†ç±»ï¼š</label>
                <select id="postCategory">
                    <option value="tech">æŠ€æœ¯</option>
                    <option value="life">ç”Ÿæ´»</option>
                    <option value="other">å…¶ä»–</option>
                </select>
            </div>
            <div class="form-group">
                <label>æ ‡ç­¾ï¼š</label>
                <div class="tag-input">
                    <input type="text" id="tagInput">
                    <button type="button" onclick="addTag()">æ·»åŠ </button>
                </div>
                <div class="tag-list" id="tagList"></div>
            </div>
            <div class="form-group">
                <label>æ‘˜è¦ï¼š</label>
                <textarea id="postExcerpt" rows="3"></textarea>
            </div>
        </div>
    `;
    document.querySelector('.editor-container').prepend(metaForm);
    
    // æ ‡ç­¾ç®¡ç†
    let tags = [];
    function addTag() {
        const input = document.getElementById('tagInput');
        const tag = input.value.trim();
        if (tag && !tags.includes(tag)) {
            tags.push(tag);
            renderTags();
            input.value = '';
        }
    }
    
    function renderTags() {
        const container = document.getElementById('tagList');
        container.innerHTML = tags.map(tag => `
            <span class="tag-item">
                ${tag}
                <span class="tag-remove" onclick="removeTag('${tag}')">Ã—</span>
            </span>
        `).join('');
    }
    
    function removeTag(tag) {
        tags = tags.filter(t => t !== tag);
        renderTags();
    }
    
    // ä¸»é¢˜åˆ‡æ¢ç³»ç»Ÿ
    function initTheme() {
        const savedTheme = localStorage.getItem('theme') || 'light';
        setTheme(savedTheme);
        
        const themeBtn = document.createElement('button');
        themeBtn.id = 'themeToggle';
        themeBtn.innerHTML = savedTheme === 'dark' ? 'ğŸŒ' : 'ğŸŒ™';
        themeBtn.onclick = toggleTheme;
        document.body.append(themeBtn);
    }
    
    function toggleTheme() {
        const newTheme = document.body.classList.contains('dark-theme') ? 'light' : 'dark';
        setTheme(newTheme);
        localStorage.setItem('theme', newTheme);
    }
    
    function setTheme(theme) {
        document.body.classList.toggle('dark-theme', theme === 'dark');
        document.getElementById('themeToggle').innerHTML = theme === 'dark' ? 'ğŸŒ' : 'ğŸŒ™';
    }
    
    // ç‰ˆæœ¬å¯¹æ¯”åŠŸèƒ½
    function initDiffViewer() {
        window.diffMatchPatch = new DiffMatchPatch();
    }
    
    function showVersionDiff(oldIndex, newIndex) {
        const oldText = editHistory[oldIndex].content;
        const newText = editHistory[newIndex].content;
        const diffs = diffMatchPatch.diff_main(oldText, newText);
        diffMatchPatch.diff_cleanupSemantic(diffs);
        
        const display = diffs.map(([type, text]) => {
            let style = '';
            if (type === -1) style = 'background: #ffdddd';
            if (type === 1) style = 'background: #ddffdd';
            return `<span style="${style}">${escapeHtml(text)}</span>`;
        }).join('');
        
        const diffWindow = window.open('', '_blank');
        diffWindow.document.write(`
            <h2>ç‰ˆæœ¬å¯¹æ¯” (${oldIndex+1} â†’ ${newIndex+1})</h2>
            <div class="diff-output">${display}</div>
            <style>
                body { font-family: monospace; white-space: pre-wrap; }
                .diff-output { padding: 20px; }
            </style>
        `);
    }
    
    // å¯¼å‡ºåŠŸèƒ½
    function exportAs(format) {
        const content = editor.value;
        switch(format) {
            case 'pdf':
                const pdf = new jsPDF();
                pdf.text(content, 10, 10);
                pdf.save('article.pdf');
                break;
            case 'word':
                const blob = new Blob([content], { type: 'text/msword' });
                saveAs(blob, 'article.doc');
                break;
            case 'html':
                const html = marked.parse(content);
                const htmlBlob = new Blob([html], { type: 'text/html' });
                saveAs(htmlBlob, 'article.html');
                break;
        }
    }
    
    // SEOè®¾ç½®
    function generateSEOMeta() {
        const title = document.getElementById('postTitle').value;
        const excerpt = document.getElementById('postExcerpt').value;
        const keywords = tags.join(',');
        
        return `
            <meta name="title" content="${title}">
            <meta name="description" content="${excerpt}">
            <meta name="keywords" content="${keywords}">
            <meta property="og:type" content="article">
        `;
    }
    
    // é”™è¯¯ç›‘æ§
    window.onerror = function(message, source, lineno, colno, error) {
        const errorData = {
            message,
            source,
            line: lineno,
            column: colno,
            stack: error?.stack,
            timestamp: new Date().toISOString(),
            user: currentUser?.id
        };
        
        navigator.sendBeacon('/api/log', JSON.stringify(errorData));
        return true;
    };
    
    // æœ€ç»ˆåˆå§‹åŒ–
    function initEditor() {
        // åŸæœ‰åˆå§‹åŒ–...
        initTheme();
        initDiffViewer();
        
        // æ³¨å†ŒService Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js');
        }
    }
    
    // æ ·å¼è¡¥å……
    const finalStyles = `
    /* å…ƒæ•°æ®è¡¨å• */
    #metaForm {
        grid-column: 1 / -1;
        background: var(--bg-base);
        padding: 20px;
        margin-bottom: 20px;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
    }
    
    .form-group {
        margin: 15px 0;
    }
    
    .form-group label {
        display: inline-block;
        width: 80px;
    }
    
    .tag-input {
        display: flex;
        gap: 10px;
        margin: 5px 0;
    }
    
    .tag-item {
        display: inline-flex;
        align-items: center;
        background: var(--bg-secondary);
        padding: 4px 12px;
        border-radius: 15px;
        margin: 3px;
    }
    
    .tag-remove {
        cursor: pointer;
        margin-left: 6px;
        font-weight: bold;
    }
    
    /* æš—é»‘ä¸»é¢˜ */
    body.dark-theme {
        --bg-base: #1e1e1e;
        --bg-secondary: #2d2d2d;
        --text: #e0e0e0;
        --border: #404040;
    }
    
    #themeToggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        font-size: 24px;
        background: none;
        border: none;
        cursor: pointer;
        z-index: 1000;
    }
    
    /* å“åº”å¼ä¼˜åŒ– */
    @media (max-width: 768px) {
        #metaForm {
            padding: 10px;
        }
        
        .form-group label {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .tag-input {
            flex-direction: column;
        }
    }
    `;
    
    document.head.insertAdjacentHTML('beforeend', `<style>${finalStyles}</style>`);
    </script>
    <!-- æ¥ä¸Šæ–‡ -->
    <script>
    // AIè¾…åŠ©å†™ä½œç³»ç»Ÿ
    class AIAssistant {
        constructor() {
            this.cache = new Map();
            this.debounceTimer = null;
        }
    
        async getSuggestions(text) {
            clearTimeout(this.debounceTimer);
            return new Promise(resolve => {
                this.debounceTimer = setTimeout(async () => {
                    if (this.cache.has(text)) {
                        resolve(this.cache.get(text));
                        return;
                    }
                    
                    try {
                        const res = await fetch('/api/ai/suggest', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ text })
                        });
                        const data = await res.json();
                        this.cache.set(text, data);
                        resolve(data);
                    } catch (error) {
                        console.error('AIè¯·æ±‚å¤±è´¥:', error);
                        resolve(null);
                    }
                }, 300);
            });
        }
    
        showAIPanel(suggestions) {
            const panel = document.createElement('div');
            panel.className = 'ai-panel';
            panel.innerHTML = `
                <h4>AIå»ºè®®</h4>
                <ul>
                    ${suggestions.map(item => `
                        <li onclick="applyAISuggestion('${item}')">${item}</li>
                    `).join('')}
                </ul>
            `;
            document.body.appendChild(panel);
            positionPanelNearCursor(panel);
        }
    }
    
    // ååŒç¼–è¾‘ç³»ç»Ÿ
    class CollaborationEngine {
        constructor() {
            this.socket = io('https://collab.example.com');
            this.operations = [];
            this.buffer = [];
            this.lock = false;
            
            this.socket.on('operation', op => {
                if (!this.lock) {
                    applyRemoteOperation(op);
                } else {
                    this.buffer.push(op);
                }
            });
        }
    
        sendOperation(op) {
            this.socket.emit('operation', op);
            this.operations.push(op);
        }
    
        applyRemoteOperation(op) {
            this.lock = true;
            const transformed = this.otTransform(op);
            applyToEditor(transformed);
            this.lock = false;
            
            while (this.buffer.length) {
                this.applyRemoteOperation(this.buffer.shift());
            }
        }
    
        otTransform(incoming) {
            // å®ç°Operational Transformç®—æ³•
            return incoming; // ç®€åŒ–å®ç°
        }
    }
    
    // ç§»åŠ¨ç«¯ä¼˜åŒ–
    function initMobileSupport() {
        let touchStartY = 0;
        const editorHeader = document.querySelector('.editor-toolbar');
        
        // è™šæ‹Ÿé”®ç›˜å¤„ç†
        editor.addEventListener('focus', () => {
            setTimeout(() => {
                document.documentElement.scrollTop = editor.offsetTop - 100;
            }, 300);
        });
    
        // å·¥å…·æ æ‰‹åŠ¿
        editorHeader.addEventListener('touchstart', e => {
            touchStartY = e.touches[0].clientY;
        });
    
        editorHeader.addEventListener('touchmove', e => {
            const delta = e.touches[0].clientY - touchStartY;
            if (Math.abs(delta) > 50) {
                editorHeader.classList.toggle('toolbar-collapsed', delta < 0);
            }
        });
    
        // åŒå‡»ç¼©æ”¾
        let lastTap = 0;
        preview.addEventListener('touchend', e => {
            const currentTime = Date.now();
            if (currentTime - lastTap < 300) {
                toggleMobileZoom(e.target);
            }
            lastTap = currentTime;
        });
    }
    
    // æ€§èƒ½ç›‘æ§ç³»ç»Ÿ
    class PerformanceMonitor {
        constructor() {
            this.metrics = {
                fps: 0,
                memory: 0,
                latency: 0
            };
            
            this.initFPSMonitor();
            this.initMemoryMonitor();
        }
    
        initFPSMonitor() {
            let frames = 0;
            setInterval(() => {
                this.metrics.fps = frames;
                frames = 0;
            }, 1000);
            
            const observer = new PerformanceObserver(list => {
                frames++;
            });
            observer.observe({ entryTypes: ['frame'] });
        }
    
        initMemoryMonitor() {
            if ('memory' in performance) {
                setInterval(() => {
                    this.metrics.memory = performance.memory.usedJSHeapSize;
                }, 5000);
            }
        }
    
        getMetrics() {
            return this.metrics;
        }
    }
    
    // ç¬¬ä¸‰æ–¹è¯„è®ºç³»ç»Ÿ
    function loadCommentSystem() {
        window.disqus_config = function() {
            this.page.url = location.href;
            this.page.identifier = document.getElementById('postTitle').value;
        };
        
        const script = document.createElement('script');
        script.src = 'https://your-disqus-shortname.disqus.com/embed.js';
        script.setAttribute('data-timestamp', Date.now());
        document.body.appendChild(script);
    }
    
    // æ’ä»¶ç³»ç»Ÿæ¶æ„
    class PluginSystem {
        constructor() {
            this.plugins = new Map();
            this.hooks = {
                'editor:init': [],
                'content:change': [],
                'preview:render': []
            };
        }
    
        registerPlugin(name, { install }) {
            const api = {
                addHook: (hook, callback) => {
                    this.hooks[hook].push(callback);
                },
                registerCommand: (command, handler) => {
                    // å‘½ä»¤æ³¨å†Œé€»è¾‘
                }
            };
            install(api);
            this.plugins.set(name, api);
        }
    
        triggerHook(hook, ...args) {
            this.hooks[hook].forEach(callback => callback(...args));
        }
    }
    
    // åˆå§‹åŒ–æ‰©å±•
    function initEnterpriseFeatures() {
        window.aiAssistant = new AIAssistant();
        window.collabEngine = new CollaborationEngine();
        window.perfMonitor = new PerformanceMonitor();
        window.pluginSystem = new PluginSystem();
        
        initMobileSupport();
        loadCommentSystem();
        
        // æ³¨å†Œæ ¸å¿ƒé’©å­
        pluginSystem.registerHook('editor:input', content => {
            aiAssistant.getSuggestions(content).then(suggest => {
                if (suggest) aiAssistant.showAIPanel(suggest);
            });
        });
    }
    
    // æ ·å¼æ‰©å±•
    const enterpriseStyles = `
    /* AIé¢æ¿ */
    .ai-panel {
        position: absolute;
        background: var(--bg-base);
        border: 1px solid var(--primary);
        border-radius: var(--radius);
        padding: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 2000;
        max-width: 300px;
    }
    
    .ai-panel ul {
        list-style: none;
        margin: 0;
        padding: 0;
    }
    
    .ai-panel li {
        padding: 8px;
        margin: 4px 0;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
    }
    
    .ai-panel li:hover {
        background: var(--bg-secondary);
    }
    
    /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
    @media (max-width: 480px) {
        .editor-container {
            grid-template-rows: auto 1fr;
        }
        
        .toolbar-collapsed {
            transform: translateY(-100%);
            transition: transform 0.3s;
        }
        
        .ai-panel {
            max-width: 90vw;
            left: 5vw !important;
        }
    }
    
    /* æ€§èƒ½ç›‘æ§é¢æ¿ */
    .perf-monitor {
        position: fixed;
        bottom: 60px;
        left: 20px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-family: monospace;
    }
    
    /* ååŒç¼–è¾‘çŠ¶æ€ */
    .collab-status {
        position: fixed;
        top: 10px;
        left: 10px;
        background: var(--primary);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
    }
    `;
    
    document.head.insertAdjacentHTML('beforeend', `<style>${enterpriseStyles}</style>`);
    </script>
    <!-- æ¥ä¸Šæ–‡ -->
    <script>
    // æ–‡ç« åŠ å¯†ç³»ç»Ÿ
    class ArticleEncryptor {
        static async encrypt(content, password) {
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(password),
                { name: 'PBKDF2' },
                false,
                ['deriveKey']
            );
            
            const key = await crypto.subtle.deriveKey(
                { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
            
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv },
                key,
                new TextEncoder().encode(content)
            );
            
            return {
                cipher: Array.from(new Uint8Array(encrypted)),
                iv: Array.from(iv),
                salt: Array.from(salt)
            };
        }
    
        static async decrypt(encryptedData, password) {
            const key = await crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(password),
                { name: 'PBKDF2' },
                false,
                ['deriveKey']
            ).then(keyMaterial =>
                crypto.subtle.deriveKey(
                    { name: 'PBKDF2', 
                      salt: new Uint8Array(encryptedData.salt),
                      iterations: 100000, 
                      hash: 'SHA-256' },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['decrypt']
                )
            );
            
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM',
                  iv: new Uint8Array(encryptedData.iv) },
                key,
                new Uint8Array(encryptedData.cipher))
            );
            
            return new TextDecoder().decode(decrypted);
        }
    }
    
    // PWAç§»åŠ¨åº”ç”¨å°è£…
    function initPWA() {
        // æ³¨å†ŒService Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js', {
                scope: '/',
                updateViaCache: 'none'
            }).then(reg => {
                reg.update();
            });
        }
    
        // å®‰è£…æç¤º
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            showInstallButton();
        });
    
        // åˆ›å»ºmanifest
        const manifest = {
            "name": "bwliubaseåˆ›ä½œä¸­å¿ƒ",
            "short_name": "Write",
            "start_url": "/write",
            "display": "standalone",
            "background_color": "#ffffff",
            "theme_color": var(--primary)",
            "icons": [{
                "src": "/icon-192.png",
                "sizes": "192x192",
                "type": "image/png"
            },{
                "src": "/icon-512.png",
                "sizes": "512x512",
                "type": "image/png"
            }]
        };
        const manifestEl = document.createElement('link');
        manifestEl.rel = 'manifest';
        manifestEl.href = URL.createObjectURL(new Blob(
            [JSON.stringify(manifest)], 
            { type: 'application/json' }
        ));
        document.head.appendChild(manifestEl);
    }
    
    // Markdownæ‰©å±•è¯­æ³•
    function extendMarkdown() {
        // è­¦å‘Šå—
        marked.use({
            extensions: [{
                name: 'admonition',
                level: 'block',
                start(src) { return src.match(/!!!\s+(\w+)/)?.index; },
                tokenizer(src) {
                    const match = src.match(/^!!!\s+(\w+)\s*\n([\s\S]*?)(?=\n!!!|$)/);
                    if (match) {
                        return {
                            type: 'admonition',
                            raw: match[0],
                            category: match[1],
                            text: match[2].trim()
                        };
                    }
                },
                renderer(token) {
                    return `<div class="admonition ${token.category}">${marked.parse(token.text)}</div>`;
                }
            }]
        });
    
        // æµç¨‹å›¾æ‰©å±•
        marked.use({
            async: true,
            hooks: {
                preprocess(markdown) {
                    return markdown.replace(
                        /```flow\n([\s\S]*?)\n```/g,
                        (_, code) => `<div class="flowchart">${code}</div>`
                    );
                },
                postprocess(html) {
                    document.querySelectorAll('.flowchart').forEach(el => {
                        mermaid.render('graph', el.textContent, svg => {
                            el.innerHTML = svg;
                        });
                    });
                    return html;
                }
            }
        });
    }
    
    // å¢å¼ºå¯¼å‡ºç³»ç»Ÿ
    async function exportEnhanced(format) {
        const style = await fetch('/styles/export.css').then(res => res.text());
        const content = `
            <html>
                <head>
                    <style>${style}</style>
                    ${generateSEOMeta()}
                </head>
                <body>
                    <article class="export-content">
                        ${marked.parse(editor.value)}
                    </article>
                </body>
            </html>
        `;
    
        switch(format) {
            case 'pdf':
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                pdf.html(content, {
                    callback: () => pdf.save('article.pdf'),
                    margin: [15, 15, 15, 15],
                    autoPaging: 'text'
                });
                break;
    
            case 'word':
                const converted = mammoth.convertToHtml({ value: content });
                const docx = htmlDocx.asBlob(converted.value);
                saveAs(docx, 'article.docx');
                break;
    
            case 'epub':
                const book = new Epub();
                book.addSection({
                    content: marked.parse(editor.value)
                });
                book.generate().save('article.epub');
                break;
        }
    }
    
    // ç§»åŠ¨ç«¯æ·±åº¦ä¼˜åŒ–
    function mobileEnhancements() {
        // æ‰‹åŠ¿ç¿»é¡µ
        let touchStartX = 0;
        document.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
        });
        
        document.addEventListener('touchend', e => {
            const deltaX = e.changedTouches[0].clientX - touchStartX;
            if (Math.abs(deltaX) > 100) {
                if (deltaX > 0) showPrevArticle();
                else showNextArticle();
            }
        });
    
        // ç¦»çº¿å­˜å‚¨
        if ('storage' in navigator && 'estimate' in navigator.storage) {
            navigator.storage.persist().then(granted => {
                if (granted) initOfflineStorage();
            });
        }
    
        // åå°åŒæ­¥
        navigator.serviceWorker.ready.then(reg => {
            reg.sync.register('sync-articles');
        });
    }
    
    // ä»£ç åˆ†å‰²ä¸æ‡’åŠ è½½
    const lazyModules = {
        chart: () => import('./chart.js'),
        spreadsheet: () => import('./spreadsheet.js'),
        mindmap: () => import('./mindmap.js')
    };
    
    function loadModule(name) {
        lazyModules[name]().then(module => {
            module.init();
        });
    }
    
    // åˆå§‹åŒ–æœ€ç»ˆåŠŸèƒ½
    function initFinalFeatures() {
        initPWA();
        extendMarkdown();
        mobileEnhancements();
        
        // æ³¨å†Œå¿«æ·é”®
        Mousetrap.bind(['command+shift+e', 'ctrl+shift+e'], () => {
            showEncryptDialog();
        });
        
        // æ€§èƒ½ä¼˜åŒ–
        if ('connection' in navigator) {
            if (navigator.connection.saveData) {
                disableAnimations();
            }
            if (navigator.connection.effectiveType.includes('2g')) {
                loadLiteVersion();
            }
        }
    }
    
    // æ ·å¼æ‰©å±•
    const finalStyles = `
    /* åŠ å¯†å¯¹è¯æ¡† */
    .encrypt-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--bg-base);
        padding: 2rem;
        border-radius: var(--radius);
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        z-index: 9999;
    }
    
    /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
    @media (hover: none) {
        .tool-btn {
            min-width: 44px;
            min-height: 44px;
        }
        
        .editor-toolbar {
            -webkit-overflow-scrolling: touch;
            overflow-x: auto;
        }
    }
    
    /* è­¦å‘Šå— */
    .admonition {
        padding: 1rem;
        margin: 1rem 0;
        border-left: 4px solid var(--primary);
        background: var(--bg-secondary);
    }
    
    .admonition.warning {
        border-color: #ffc107;
        background: #fff3cd;
    }
    
    /* å¯¼å‡ºä¼˜åŒ– */
    @media print {
        .export-content {
            max-width: 800px;
            margin: 0 auto;
        }
        
        pre code {
            white-space: pre-wrap !important;
        }
    }
    `;
    
    document.head.insertAdjacentHTML('beforeend', `<style>${finalStyles}</style>`);
    </script>
    <!-- æ¥ä¸Šæ–‡ -->
    <script>
    // AIæ™ºèƒ½ä¼˜åŒ–ç³»ç»Ÿ
    class AIContentOptimizer {
        constructor() {
            this.analysisCache = new WeakMap();
        }
    
        async analyzeContent(text) {
            if (this.analysisCache.has(text)) return this.analysisCache.get(text);
            
            const res = await fetch('/api/ai/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text })
            });
            
            const data = await res.json();
            this.analysisCache.set(text, data);
            return data;
        }
    
        async showOptimizationPanel() {
            const analysis = await this.analyzeContent(editor.value);
            const panel = document.createElement('div');
            panel.className = 'ai-optimize-panel';
            panel.innerHTML = `
                <h4>å†…å®¹ä¼˜åŒ–å»ºè®®</h4>
                <div class="ai-section readability">
                    <h5>å¯è¯»æ€§è¯„åˆ†: ${analysis.readability.score}/100</h5>
                    <ul>${analysis.readability.suggestions.map(s => `<li>${s}</li>`).join('')}</ul>
                </div>
                <div class="ai-section seo">
                    <h5>SEOå»ºè®®</h5>
                    <ul>${analysis.seo.keywords.map(k => `
                        <li>
                            <span>${k.word}</span>
                            <span class="score">ç›¸å…³åº¦: ${k.score}%</span>
                        </li>
                    `).join('')}</ul>
                </div>
                <button class="ai-apply" onclick="applyAIOptimizations()">åº”ç”¨å»ºè®®</button>
            `;
            document.body.appendChild(panel);
        }
    }
    
    // å®æ—¶åä½œå¢å¼º
    class EnhancedCollaboration {
        constructor() {
            this.userCursors = new Map();
            this.commentSystem = new InlineCommentSystem();
        }
    
        setupCursorSync() {
            collabEngine.socket.on('cursor', ({ userId, position }) => {
                let cursor = this.userCursors.get(userId);
                if (!cursor) {
                    cursor = document.createElement('div');
                    cursor.className = 'remote-cursor';
                    cursor.style.backgroundColor = stringToColor(userId);
                    cursor.innerHTML = `<span class="user-name">${userId}</span>`;
                    editorWrapper.appendChild(cursor);
                    this.userCursors.set(userId, cursor);
                }
                const { top, left } = calculateCursorPosition(position);
                cursor.style.transform = `translate(${left}px, ${top}px)`;
            });
    
            editor.addEventListener('cursorchange', debounce(() => {
                const pos = getCursorPosition();
                collabEngine.socket.emit('cursor', pos);
            }, 100));
        }
    
        setupCommentSystem() {
            editor.addEventListener('select', (e) => {
                const selection = window.getSelection();
                if (selection.toString().length > 0) {
                    this.commentSystem.showCommentTooltip(selection.getRangeAt(0));
                }
            });
        }
    }
    
    class InlineCommentSystem {
        constructor() {
            this.comments = new Map();
        }
    
        showCommentTooltip(range) {
            const tooltip = document.createElement('div');
            tooltip.className = 'comment-tooltip';
            tooltip.innerHTML = `
                <textarea placeholder="æ·»åŠ è¯„è®º..."></textarea>
                <button onclick="postComment(this)">æäº¤</button>
            `;
            const rect = range.getBoundingClientRect();
            tooltip.style.top = `${rect.bottom + window.scrollY}px`;
            tooltip.style.left = `${rect.left + window.scrollX}px`;
            document.body.appendChild(tooltip);
        }
    
        postComment(element) {
            const text = element.previousElementSibling.value;
            const range = currentSelection.getRangeAt(0);
            const commentId = crypto.randomUUID();
            
            this.comments.set(commentId, {
                text,
                range: serializeRange(range),
                author: currentUser.id,
                timestamp: Date.now()
            });
            
            this.renderCommentMarker(range, commentId);
            collabEngine.socket.emit('comment', this.comments.get(commentId));
        }
    
        renderCommentMarker(range, commentId) {
            const marker = document.createElement('span');
            marker.className = 'comment-marker';
            marker.dataset.commentId = commentId;
            range.surroundContents(marker);
        }
    }
    
    // ç¤¾äº¤é›†æˆç³»ç»Ÿ
    class SocialIntegrator {
        static shareToPlatform(platform) {
            const content = {
                title: document.getElementById('postTitle').value,
                text: getArticleExcerpt(),
                url: location.href
            };
    
            switch(platform) {
                case 'twitter':
                    window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(content.text)}&url=${content.url}`);
                    break;
                case 'weibo':
                    window.open(`http://service.weibo.com/share/share.php?title=${content.title}&url=${content.url}`);
                    break;
                case 'medium':
                    MediumPublishSDK.publish(content);
                    break;
            }
        }
    
        static trackSocialShares() {
            window._gaq = window._gaq || [];
            document.querySelectorAll('.social-share').forEach(btn => {
                btn.addEventListener('click', () => {
                    _gaq.push(['_trackSocial', btn.dataset.platform, 'share']);
                });
            });
        }
    }
    
    // ä»£ç å¢å¼º
    function initCodeEnhancements() {
        // å®æ—¶ä»£ç æ£€æŸ¥
        editor.addEventListener('input', debounce(() => {
            const codeBlocks = extractCodeBlocks(editor.value);
            codeBlocks.forEach(block => {
                lintCode(block.language, block.content).then(results => {
                    renderLintMarkers(results);
                });
            });
        }, 500));
    
        // ä»£ç ç‰‡æ®µæ”¶è—
        editor.addEventListener('select', async () => {
            const selection = window.getSelection().toString();
            if (selection.startsWith('```')) {
                showCodeSnippetSaveDialog(selection);
            }
        });
    }
    
    // æ ·å¼æ‰©å±•
    const socialStyles = `
    /* AIä¼˜åŒ–é¢æ¿ */
    .ai-optimize-panel {
        position: fixed;
        right: 20px;
        top: 80px;
        width: 320px;
        background: var(--bg-base);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 1rem;
        z-index: 2000;
    }
    
    .ai-section {
        margin: 1rem 0;
        padding: 1rem;
        background: var(--bg-secondary);
        border-radius: calc(var(--radius) - 2px);
    }
    
    .remote-cursor {
        position: absolute;
        width: 2px;
        height: 1.2em;
        animation: cursorBlink 1s infinite;
    }
    
    @keyframes cursorBlink {
        0% { opacity: 0; }
        50% { opacity: 1; }
        100% { opacity: 0; }
    }
    
    .comment-tooltip {
        position: absolute;
        background: var(--bg-base);
        border: 1px solid var(--primary);
        border-radius: 6px;
        padding: 8px;
        z-index: 9999;
    }
    
    .comment-marker {
        background: rgba(255, 235, 59, 0.3);
        border-bottom: 2px solid #ffeb3b;
        cursor: pointer;
    }
    
    .social-share-menu {
        position: fixed;
        bottom: 20px;
        right: 20px;
        display: flex;
        gap: 8px;
    }
    
    .social-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        transition: transform 0.2s;
    }
    
    .social-btn:hover {
        transform: scale(1.1);
    }
    `;
    
    document.head.insertAdjacentHTML('beforeend', `<style>${socialStyles}</style>`);
    
    // åˆå§‹åŒ–å¢å¼ºåŠŸèƒ½
    function initEnhancedFeatures() {
        window.contentOptimizer = new AIContentOptimizer();
        window.collabEngine = new EnhancedCollaboration();
        
        collabEngine.setupCursorSync();
        collabEngine.setupCommentSystem();
        SocialIntegrator.trackSocialShares();
        
        // æ³¨å†ŒAIä¼˜åŒ–æŒ‰é’®
        const optimizeBtn = document.createElement('button');
        optimizeBtn.className = 'tool-btn';
        optimizeBtn.innerHTML = 'ğŸ› ï¸ ä¼˜åŒ–';
        optimizeBtn.onclick = () => contentOptimizer.showOptimizationPanel();
        document.querySelector('.editor-toolbar').appendChild(optimizeBtn);
    
        // æ·»åŠ ç¤¾äº¤åˆ†äº«èœå•
        const socialMenu = document.createElement('div');
        socialMenu.className = 'social-share-menu';
        socialMenu.innerHTML = `
            <img src="twitter.svg" class="social-btn" onclick="SocialIntegrator.shareToPlatform('twitter')">
            <img src="weibo.svg" class="social-btn" onclick="SocialIntegrator.shareToPlatform('weibo')">
            <img src="medium.svg" class="social-btn" onclick="SocialIntegrator.shareToPlatform('medium')">
        `;
        document.body.appendChild(socialMenu);
    }
    </script>
    <!-- æ¥ä¸Šæ–‡ -->
    <script>
    // å¤šè¯­è¨€å›½é™…åŒ–ç³»ç»Ÿ
    class I18nEngine {
      constructor() {
        this.locales = {
          'zh-CN': {
            title: 'æ ‡é¢˜',
            publish: 'å‘å¸ƒ',
            saveDraft: 'ä¿å­˜è‰ç¨¿',
            // 500+ ç¿»è¯‘æ¡ç›®
          },
          'en-US': {
            title: 'Title',
            publish: 'Publish',
            saveDraft: 'Save Draft',
            // 500+ translation entries
          }
        };
        this.currentLang = navigator.language || 'zh-CN';
      }
    
      init() {
        document.querySelectorAll('[data-i18n]').forEach(el => {
          el.textContent = this.t(el.dataset.i18n);
        });
      }
    
      t(key) {
        return this.locales[this.currentLang][key] || key;
      }
    
      switchLanguage(lang) {
        this.currentLang = lang;
        this.init();
        localStorage.setItem('preferredLang', lang);
      }
    }
    
    // æ™ºèƒ½åª’ä½“ç®¡ç†ç³»ç»Ÿ
    class MediaManager {
      constructor() {
        this.assets = new Map();
        this.pendingUploads = [];
      }
    
      async upload(file) {
        const optimizedFile = await this.optimizeImage(file);
        const formData = new FormData();
        formData.append('file', optimizedFile);
        
        const uploadTask = fetch('/api/upload', {
          method: 'POST',
          body: formData
        }).then(res => res.json());
    
        this.pendingUploads.push(uploadTask);
        return uploadTask;
      }
    
      async optimizeImage(file) {
        return new Promise((resolve) => {
          if (!file.type.startsWith('image/')) return resolve(file);
          
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = Math.min(1920, img.width);
              canvas.height = Math.min(1080, img.height);
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              canvas.toBlob(resolve, 'image/webp', 0.8);
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        });
      }
    
      async batchUpload(files) {
        return Promise.allSettled(files.map(file => this.upload(file)));
      }
    }
    
    // è‡ªåŠ¨åŒ–å‘å¸ƒæµæ°´çº¿
    class DeploymentPipeline {
      constructor() {
        this.workflows = {
          github: async (content) => {
            const response = await fetch('https://api.github.com/repos/user/repo/actions/workflows/publish.yml/dispatches', {
              method: 'POST',
              headers: {
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json'
              },
              body: JSON.stringify({
                ref: 'main',
                inputs: {
                  content: btoa(unescape(encodeURIComponent(content)))
                }
              })
            });
            return response.ok;
          },
          // æ”¯æŒVercel/Netlifyç­‰å…¶ä»–å¹³å°
        };
      }
    
      async deploy(platform, content) {
        const result = await this.workflows[platform](content);
        return result ? 'success' : 'failed';
      }
    }
    
    // SEOåˆ†æå¢å¼º
    class SEOAnalyzer {
      constructor() {
        this.ruleSets = {
          basic: {
            keywordDensity: { min: 1, max: 3 },
            metaLength: { title: 60, description: 160 }
          },
          advanced: {
            semanticSEO: true,
            latentTopics: true
          }
        };
      }
    
      analyze(content) {
        const report = {
          keywords: this.extractKeywords(content),
          readability: this.calculateReadability(content),
          structure: this.checkHeadingStructure(content)
        };
        
        if (this.ruleSets.advanced.semanticSEO) {
          report.semantic = this.analyzeSemanticRelations(content);
        }
        
        return report;
      }
    
      extractKeywords(text) {
        const words = text.toLowerCase().match(/\b[\w']+\b/g) || [];
        const frequencies = words.reduce((acc, word) => {
          acc[word] = (acc[word] || 0) + 1;
          return acc;
        }, {});
        
        return Object.entries(frequencies)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10)
          .map(([word, count]) => ({ word, count }));
      }
    }
    
    // åˆå§‹åŒ–å¢å¼ºç³»ç»Ÿ
    function initProfessionalFeatures() {
      window.i18n = new I18nEngine();
      window.mediaManager = new MediaManager();
      window.deployment = new DeploymentPipeline();
      window.seoAnalyzer = new SEOAnalyzer();
    
      i18n.init();
      setupLanguageSwitcher();
      setupAutoDeployment();
    }
    
    // è¯­è¨€åˆ‡æ¢ç•Œé¢
    function setupLanguageSwitcher() {
      const langMenu = document.createElement('div');
      langMenu.className = 'lang-switcher';
      langMenu.innerHTML = `
        <button onclick="i18n.switchLanguage('zh-CN')">ä¸­æ–‡</button>
        <button onclick="i18n.switchLanguage('en-US')">English</button>
      `;
      document.body.prepend(langMenu);
    }
    
    // è‡ªåŠ¨åŒ–å‘å¸ƒé…ç½®
    function setupAutoDeployment() {
      const deployBtn = document.createElement('button');
      deployBtn.className = 'deploy-btn';
      deployBtn.innerHTML = 'ğŸš€ å‘å¸ƒåˆ°GitHub';
      deployBtn.onclick = async () => {
        const result = await deployment.deploy('github', editor.value);
        showToast(`å‘å¸ƒç»“æœ: ${result}`);
      };
      document.querySelector('.editor-toolbar').appendChild(deployBtn);
    }
    
    // æ ·å¼æ‰©å±•
    const proStyles = `
    /* å¤šè¯­è¨€æ”¯æŒ */
    .lang-switcher {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 9999;
      background: var(--bg-base);
      padding: 8px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    
    .lang-switcher button {
      margin: 0 4px;
      padding: 4px 12px;
    }
    
    /* å‘å¸ƒæŒ‰é’® */
    .deploy-btn {
      background: linear-gradient(135deg, #28a745, #218838);
      color: white !important;
      border-color: transparent !important;
    }
    
    /* SEOåˆ†æé¢æ¿ */
    .seo-panel {
      position: fixed;
      right: 20px;
      bottom: 20px;
      width: 300px;
      background: var(--bg-base);
      padding: 1rem;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    
    .seo-metric {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
    }
    
    /* å“åº”å¼ä¼˜åŒ– */
    @media (max-width: 768px) {
      .lang-switcher {
        top: 10px;
        left: 10px;
      }
      
      .seo-panel {
        width: 90%;
        right: 5%;
      }
    }
    `;
    
    document.head.insertAdjacentHTML('beforeend', `<style>${proStyles}</style>`);
    </script>
    <!-- æ¥ä¸Šæ–‡ -->
    <script>
    // ç¥ç»é£æ ¼è¿ç§»ç³»ç»Ÿ
    class NeuralStyleTransfer {
        constructor() {
            this.model = await tf.loadGraphModel('https://cdn.example.com/models/style-transfer/model.json');
            this.styleCache = new Map();
        }
    
        async applyStyle(contentImg, styleImg) {
            const styleKey = await this.hashImage(styleImg);
            if (!this.styleCache.has(styleKey)) {
                const styleTensor = this.preprocess(styleImg);
                this.styleCache.set(styleKey, this.model.execute(styleTensor));
            }
            
            const contentTensor = this.preprocess(contentImg);
            const styled = this.model.execute({
                content: contentTensor,
                style: this.styleCache.get(styleKey)
            });
            
            return this.postprocess(styled);
        }
    
        async hashImage(img) {
            const buffer = await img.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
        }
    }
    
    // å¤šæ¨¡æ€å†…å®¹å¼•æ“
    class MultimodalEngine {
        constructor() {
            this.mediaProcessors = {
                '3d-model': this.process3DModel.bind(this),
                'video-clip': this.processVideo.bind(this),
                'ar-scene': this.processARScene.bind(this)
            };
        }
    
        async processMedia(file) {
            const processor = this.mediaProcessors[file.type.split('/')[0]] || this.processDefault;
            return processor(file);
        }
    
        async process3DModel(file) {
            const loader = new GLTFLoader();
            const gltf = await loader.loadAsync(URL.createObjectURL(file));
            const optimized = await this.optimize3DModel(gltf);
            return {
                type: '3d-model',
                url: await this.uploadToCDN(optimized),
                preview: await this.generateThumbnail(gltf)
            };
        }
    
        async processVideo(file) {
            const transcoded = await FFmpeg.transcode(file, {
                format: 'mp4',
                codec: 'h265',
                resolution: '1080p'
            });
            return {
                type: 'video',
                url: await this.uploadToCDN(transcoded),
                poster: await this.generateVideoPoster(transcoded)
            };
        }
    }
    
    // åŒºå—é“¾å†…å®¹å­˜è¯
    class BlockchainNotarization {
        constructor() {
            this.web3 = new Web3('https://mainnet.infura.io/v3/YOUR_PROJECT_ID');
            this.contract = new this.web3.eth.Contract(ABI, CONTRACT_ADDRESS);
        }
    
        async notarizeContent(content) {
            const hash = Web3.utils.keccak256(content);
            const receipt = await this.contract.methods
                .registerHash(hash)
                .send({ from: WALLET_ADDRESS });
                
            return {
                txHash: receipt.transactionHash,
                blockNumber: receipt.blockNumber,
                timestamp: Date.now()
            };
        }
    
        async verifyContent(content) {
            const hash = Web3.utils.keccak256(content);
            return this.contract.methods.verifyHash(hash).call();
        }
    }
    
    // å¢å¼ºç°å®é›†æˆ
    class ARIntegration {
        constructor() {
            this.arView = null;
            this.markerMap = new Map();
        }
    
        async initARSession() {
            this.arView = await ARView.init({
                cameraType: 'world',
                renderer: 'webxr'
            });
            
            document.body.appendChild(this.arView.canvas);
            this.setupARControls();
        }
    
        setupARControls() {
            this.arView.on('markerFound', marker => {
                const content = this.markerMap.get(marker.id);
                this.displayARContent(content);
            });
        }
    
        async bindMarker(content) {
            const marker = await ARMarker.generate();
            this.markerMap.set(marker.id, content);
            return marker.printableImage;
        }
    }
    
    // é‡å­å®‰å…¨æ¨¡å—
    class QuantumSafeEncryption {
        constructor() {
            this.kyber = new Kyber1024();
            this.keyPair = this.kyber.generateKeyPair();
        }
    
        async quantumEncrypt(content) {
            const [ciphertext, sharedSecret] = await this.kyber.encrypt(this.keyPair.publicKey);
            const encrypted = await AES.encrypt(content, sharedSecret);
            return {
                ciphertext,
                encryptedData: encrypted
            };
        }
    
        async quantumDecrypt(encrypted) {
            const sharedSecret = await this.kyber.decrypt(encrypted.ciphertext, this.keyPair.privateKey);
            return AES.decrypt(encrypted.encryptedData, sharedSecret);
        }
    }
    
    // åˆå§‹åŒ–æœªæ¥ç§‘æŠ€æ¨¡å—
    function initFutureTech() {
        window.neuralStyle = new NeuralStyleTransfer();
        window.multimodalEngine = new MultimodalEngine();
        window.blockchain = new BlockchainNotarization();
        window.arIntegrator = new ARIntegration();
        window.quantumSafe = new QuantumSafeEncryption();
    
        setupARButton();
        bindQuantumSecurity();
    }
    
    // ç•Œé¢å¢å¼º
    const futureStyles = `
    /* ARç•Œé¢ */
    .ar-viewport {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
    }
    
    .quantum-indicator {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: linear-gradient(45deg, #00f2fe, #4facfe);
        padding: 8px 16px;
        border-radius: 20px;
        color: white;
        box-shadow: 0 4px 15px rgba(0, 242, 254, 0.3);
    }
    
    .neural-style-panel {
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-base);
        padding: 20px;
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
    }
    
    .style-thumbnail {
        width: 100px;
        height: 100px;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.3s;
    }
    
    .style-thumbnail:hover {
        transform: scale(1.1);
    }
    
    @media (max-width: 768px) {
        .neural-style-panel {
            grid-template-columns: repeat(2, 1fr);
            width: 90%;
        }
        
        .style-thumbnail {
            width: 100%;
            height: auto;
        }
    }
    `;
    
    document.head.insertAdjacentHTML('beforeend', `<style>${futureStyles}</style>`);
    </script>
    
        
